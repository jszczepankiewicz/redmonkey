package dynks.cache;

import org.assertj.core.api.AbstractAssert;
import org.assertj.core.util.Objects;

/**
 * {@link CacheRegion} specific assertions - Generated by CustomAssertionGenerator.
 */
public class CacheRegionAssert extends AbstractAssert<CacheRegionAssert, CacheRegion> {

  /**
   * Creates a new <code>{@link CacheRegionAssert}</code> to make assertions on actual CacheRegion.
   * @param actual the CacheRegion we want to make assertions on.
   */
  public CacheRegionAssert(CacheRegion actual) {
    super(actual, CacheRegionAssert.class);
  }

  /**
   * An entry point for CacheRegionAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
   * With a static import, one can write directly: <code>assertThat(myCacheRegion)</code> and get specific assertion with code completion.
   * @param actual the CacheRegion we want to make assertions on.
   * @return a new <code>{@link CacheRegionAssert}</code>
   */
  public static CacheRegionAssert assertThat(CacheRegion actual) {
    return new CacheRegionAssert(actual);
  }

  /**
   * Verifies that the actual CacheRegion's ttl is equal to the given one.
   * @param ttl the given ttl to compare the actual CacheRegion's ttl to.
   * @return this assertion object.
   * @throws AssertionError - if the actual CacheRegion's ttl is not equal to the given one.
   */
  public CacheRegionAssert hasTtl(long ttl) {
    // check that actual CacheRegion we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpected ttl of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
    
    // check
    long actualTtl = actual.getTtl();
    if (actualTtl != ttl) {
      failWithMessage(assertjErrorMessage, actual, ttl, actualTtl);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual CacheRegion's ttlUnit is equal to the given one.
   * @param ttlUnit the given ttlUnit to compare the actual CacheRegion's ttlUnit to.
   * @return this assertion object.
   * @throws AssertionError - if the actual CacheRegion's ttlUnit is not equal to the given one.
   */
  public CacheRegionAssert hasTtlUnit(java.util.concurrent.TimeUnit ttlUnit) {
    // check that actual CacheRegion we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpected ttlUnit of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
    
    // null safe check
    java.util.concurrent.TimeUnit actualTtlUnit = actual.getTtlUnit();
    if (!Objects.areEqual(actualTtlUnit, ttlUnit)) {
      failWithMessage(assertjErrorMessage, actual, ttlUnit, actualTtlUnit);
    }

    // return the current assertion for method chaining
    return this;
  }

  /**
   * Verifies that the actual CacheRegion's volatility is equal to the given one.
   * @param volatility the given volatility to compare the actual CacheRegion's volatility to.
   * @return this assertion object.
   * @throws AssertionError - if the actual CacheRegion's volatility is not equal to the given one.
   */
  public CacheRegionAssert hasVolatility(CacheRegion.Cacheability volatility) {
    // check that actual CacheRegion we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpected volatility of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
    
    // null safe check
    CacheRegion.Cacheability actualVolatility = actual.getCacheability();
    if (!Objects.areEqual(actualVolatility, volatility)) {
      failWithMessage(assertjErrorMessage, actual, volatility, actualVolatility);
    }

    // return the current assertion for method chaining
    return this;
  }

}
